[{"path":[]},{"path":"/articles/disease_outcome_classification_schulte.html","id":"description","dir":"Articles","previous_headings":"Overview","what":"Description","title":"Disease Outcome Classification in Single Cell Patient Data Analysis","text":"single-cell technology advances, number multi-condition multi-sample datasets increases. workshop discuss challenges analytical focus associated disease outcome prediction using multi-condition multi-sample single cell dataset. also talk general analytic strategies critical thinking questions arise workflow.","code":""},{"path":"/articles/disease_outcome_classification_schulte.html","id":"preparation-and-assumed-knowledge","dir":"Articles","previous_headings":"Overview","what":"Preparation and assumed knowledge","title":"Disease Outcome Classification in Single Cell Patient Data Analysis","text":"Knowledge R syntax Familiarity Seurat class","code":""},{"path":"/articles/disease_outcome_classification_schulte.html","id":"learning-objectives","dir":"Articles","previous_headings":"Overview","what":"Learning objectives","title":"Disease Outcome Classification in Single Cell Patient Data Analysis","text":"Explore various strategies disease outcome prediction using single cell data Understand transformation cell level features patient level features Generate patient representations gene expression matrix Understand characteristics good classification models Perform disease outcome prediction using feature representation robust classification framework","code":""},{"path":"/articles/disease_outcome_classification_schulte.html","id":"time-outline","dir":"Articles","previous_headings":"Overview","what":"Time outline","title":"Disease Outcome Classification in Single Cell Patient Data Analysis","text":"Structure 3-hour workshop:","code":""},{"path":"/articles/disease_outcome_classification_schulte.html","id":"introduction","dir":"Articles","previous_headings":"","what":"1. Introduction","title":"Disease Outcome Classification in Single Cell Patient Data Analysis","text":"rise single-cell near single-cell resolution omics technologies (e.g. spatial transcriptomics) enabled discovery cell- cell type specific knowledge transformed understanding biological systems. high-dimensionality complexity, 1000 tools developed extract meaningful information high feature dimensions uncover biological insights. example, previous workshop focuses characterising identity state cells relationship cells along trajectory. tools enable characterisation individual cells, lack tools characterise individual samples whole based cellular properties investigate cellular properties driving disease outcomes. recent surge multi-condition multi-sample single-cell studies, question becomes represent cellular properties sample (e.g. individual patient) level linking information disease outcome performing downstream analysis disease outcome prediction. workshop, demonstrate approach generating molecular representation individual samples using representation downstream application disease outcome classification.","code":""},{"path":[]},{"path":"/articles/disease_outcome_classification_schulte.html","id":"load-libraries","dir":"Articles","previous_headings":"2. Loading libraries and the data","what":"2.1 Load libraries","title":"Disease Outcome Classification in Single Cell Patient Data Analysis","text":"First, load libraries using workshop.","code":"library(ggplot2) library(plotly) library(ggthemes) theme_set(theme_bw()) library(Seurat) library(dplyr) library(devtools)  library(RCurl) library(UpSetR) library(scFeatures) library(ClassifyR) library(limma)  set.seed(2022)"},{"path":"/articles/disease_outcome_classification_schulte.html","id":"loading-the-preprocessed-data","dir":"Articles","previous_headings":"2. Loading libraries and the data","what":"2.2 Loading the preprocessed data","title":"Disease Outcome Classification in Single Cell Patient Data Analysis","text":"use single-cell RNA-sequencing (scRNA-seq) data COVID-19 patients workshop. dataset taken Schulte-Schrepping et al. 2020. subsampled 12 patient samples (5 mild/moderate 7 severe/critical) dataset, condition mild/moderate severe/critical. original data can accessed European Genome-phenome Archive (EGA) accession number EGAS00001004571.","code":"data <-  readRDS(\"~/toy_data/schulte_12patients.rds\")"},{"path":"/articles/disease_outcome_classification_schulte.html","id":"visualising-the-data","dir":"Articles","previous_headings":"2. Loading libraries and the data","what":"2.3 Visualising the data","title":"Disease Outcome Classification in Single Cell Patient Data Analysis","text":"can visualise data using dimensionality reduction approaches colour individual cells severity.  Interpretation: cells mild/moderate severe/critical patients easy difficult distinguish?","code":"# here we use the standard data processing pipelines from Seurat # you read about the details of each function by typing question marks, e.g., \"?NormalizeData\" data <- NormalizeData( data) # log transform the data  data <-  FindVariableFeatures(data )   # find variable features for dimension reduction  data <- ScaleData(data, features = rownames(data) ) # scale the data and center the data for dimension reduction   # run PCA data <- RunPCA(data, verbose = FALSE) #here, we use verbose = FALSE to suppress the text output   # run clustering  data <- FindNeighbors(data, dims = 1:10) data <- FindClusters(data)  #> Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck #>  #> Number of nodes: 11679 #> Number of edges: 394547 #>  #> Running Louvain algorithm... #> Maximum modularity in 10 random starts: 0.9112 #> Number of communities: 21 #> Elapsed time: 2 seconds  # run UMAP data  <- RunUMAP(data , dims = 1:10) DimPlot(data, reduction = \"umap\", group.by = \"meta_severity\") + DimPlot(data, reduction = \"umap\", group.by = \"sample\")"},{"path":"/articles/disease_outcome_classification_schulte.html","id":"how-can-i-characterise-each-individual-as-a-whole-from-the-matrix-of-genes-x-cells","dir":"Articles","previous_headings":"","what":"3. How can I characterise each individual as a whole from the matrix of genes x cells ?","title":"Disease Outcome Classification in Single Cell Patient Data Analysis","text":"workshop, use scFeatures generate molecular representation patient. molecular representation interpretable hence facilitates downstream analysis patient. Overall, scFeatures generates features across six categories representing different molecular views cellular characteristics. include: - ) cell type proportions - ii) cell type specific gene expressions - iii) cell type specific pathway expressions - iv) cell type specific cell-cell interaction (CCI) scores - v) overall aggregated gene expressions - vi) spatial metrics different types features constructed enable comprehensive multi-view understanding patient matrix genes x cells.","code":""},{"path":"/articles/disease_outcome_classification_schulte.html","id":"checking-the-data","dir":"Articles","previous_headings":"3. How can I characterise each individual as a whole from the matrix of genes x cells ?","what":"3.1 Checking the data","title":"Disease Outcome Classification in Single Cell Patient Data Analysis","text":"Inspect number cells patient sample, well number cells cell type. Discussion: sample cell types remove data? scFeatures also built-function process_data, removes “small samples”, sample less 10 cells every cell type. Discussion: running process_data function, still patient samples cell types remove data?","code":"table(data$sample) #>  #> BN-18_FreshEryLysis_12.05.2020-FreshEryLysis  #>                                         1000  #>                        C19-CB-0002_d13-Fresh  #>                                         1000  #>                        C19-CB-0002_d8-Frozen  #>                                         1000  #>                        C19-CB-0003_d13-Fresh  #>                                         1000  #>                       C19-CB-0003_d18-Frozen  #>                                         1000  #>                        C19-CB-0008_d13-Fresh  #>                                         1000  #>                        C19-CB-0009_d16-Fresh  #>                                         1000  #>                         C19-CB-0009_d9-Fresh  #>                                          938  #>                         C19-CB-0012_d9-Fresh  #>                                          741  #>                        C19-CB-0021_d18-Fresh  #>                                         1000  #>                        C19-CB-0198_d18-Fresh  #>                                         1000  #>                         C19-CB-0214_d7-Fresh  #>                                         1000 table(data$celltype) #>  #>            B    CD14 Mono    CD16 Mono        CD4 T        CD8 T           DC  #>          654         2617          314         2162          725          128  #>           DN          gdT         HSPC          ILC intermediate         MAIT  #>           14          156           19            1          232          156  #>         MAST   Neutrophil           NK          NKT       Plasma     Platelet  #>            8         2008         1189          811          204          134  #>          RBC   unassigned  #>            1          146  data <- process_data(data)  table(data$sample) #>  #> BN-18_FreshEryLysis_12.05.2020-FreshEryLysis  #>                                         1000  #>                        C19-CB-0002_d13-Fresh  #>                                         1000  #>                        C19-CB-0002_d8-Frozen  #>                                         1000  #>                        C19-CB-0003_d13-Fresh  #>                                         1000  #>                       C19-CB-0003_d18-Frozen  #>                                         1000  #>                        C19-CB-0008_d13-Fresh  #>                                         1000  #>                        C19-CB-0009_d16-Fresh  #>                                         1000  #>                         C19-CB-0009_d9-Fresh  #>                                          938  #>                         C19-CB-0012_d9-Fresh  #>                                          741  #>                        C19-CB-0021_d18-Fresh  #>                                         1000  #>                        C19-CB-0198_d18-Fresh  #>                                         1000  #>                         C19-CB-0214_d7-Fresh  #>                                         1000 table(data$celltype) #>  #>            B    CD14 Mono    CD16 Mono        CD4 T        CD8 T           DC  #>          654         2617          314         2162          725          128  #>           DN          gdT         HSPC          ILC intermediate         MAIT  #>           14          156           19            1          232          156  #>         MAST   Neutrophil           NK          NKT       Plasma     Platelet  #>            8         2008         1189          811          204          134  #>          RBC   unassigned  #>            1          146 # remove MAST, DN, ILC, HSPC, RBC  data <- data[, -c(which( data$celltype %in% c(\"MAST\", \"DN\", \"ILC\", \"HSPC\", \"RBC\")))]"},{"path":"/articles/disease_outcome_classification_schulte.html","id":"creating-molecular-representations-of-patients","dir":"Articles","previous_headings":"3. How can I characterise each individual as a whole from the matrix of genes x cells ?","what":"3.1 Creating molecular representations of patients","title":"Disease Outcome Classification in Single Cell Patient Data Analysis","text":"feature types can generated one line code. runs function using default settings parameters, information, type ?scFeatures. Given step may take 20 minutes, already generated result saved intermediate_result folder. skip step proceed next step purposes workshop.","code":"# Here we label the samples using the severity, such as it is easier later on to retrieve the severity outcomes of the samples.  data$sample <- paste0(data$sample, \"_cond_\" , data$meta_severity)  # scfeatures uses the log normalised data scfeatures_result <- scFeatures(data, ncores = 12)"},{"path":"/articles/disease_outcome_classification_schulte.html","id":"visualising-and-exploring-scfeatures-output","dir":"Articles","previous_headings":"3. How can I characterise each individual as a whole from the matrix of genes x cells ?","what":"3.2 Visualising and exploring scFeatures output","title":"Disease Outcome Classification in Single Cell Patient Data Analysis","text":"generated total 13 feature types stored list. generated feature types stored matrix samples features. example, first list element contains feature type “proportion_raw”, contains cell type proportion features patient sample. print first 5 columns first 5 rows first element see. features generated, may wish visually explore features. example, cell type specific gene expression score, volcano plot provide direct insight matrix values. accommodate need, scFeatures contains function run_association_study_report enables user readily visualise explore generated features one line code. Note, function knits HTML file, please paste following command console run .","code":"scfeatures_result <- readRDS(\"~/intermediate_result/scfeatures_result_schulte_12patients.rds\")  # we have generated a total of 13 feature types names(scfeatures_result) #>  [1] \"proportion_raw\"     \"proportion_logit\"   \"proportion_ratio\"   #>  [4] \"gene_mean_celltype\" \"gene_prop_celltype\" \"gene_cor_celltype\"  #>  [7] \"pathway_gsva\"       \"pathway_mean\"       \"pathway_prop\"       #> [10] \"CCI\"                \"gene_mean_bulk\"     \"gene_prop_bulk\"     #> [13] \"gene_cor_bulk\"  # each row is a sample, each column is a feature  scfeatures_result[[1]][1:5, 1:5] #>                                                    B  CD14 Mono  CD16 Mono #> C19-CB-0003_d13-Fresh_cond_Mild/Moderate  0.15245737 0.56870612 0.06218656 #> C19-CB-0002_d13-Fresh_cond_Mild/Moderate  0.23123123 0.27327327 0.03203203 #> C19-CB-0002_d8-Frozen_cond_Mild/Moderate  0.06700000 0.27800000 0.03000000 #> C19-CB-0003_d18-Frozen_cond_Mild/Moderate 0.03200000 0.57400000 0.13400000 #> C19-CB-0009_d9-Fresh_cond_Severe/Critical 0.01611171 0.09344791 0.00000000 #>                                                CD4 T      CD8 T #> C19-CB-0003_d13-Fresh_cond_Mild/Moderate  0.02407222 0.02407222 #> C19-CB-0002_d13-Fresh_cond_Mild/Moderate  0.06006006 0.05205205 #> C19-CB-0002_d8-Frozen_cond_Mild/Moderate  0.04600000 0.06200000 #> C19-CB-0003_d18-Frozen_cond_Mild/Moderate 0.01700000 0.03600000 #> C19-CB-0009_d9-Fresh_cond_Severe/Critical 0.33941998 0.05263158 data <- scfeatures_result$gene_mean_celltype # this transposes the data # in bioinformatics conversion, features are stored in rows  # in statistics convention, features are stored in columns data <- t(data)        # pick CD14 Mono as an example cell type  data <- data[ grep(\"CD14\", rownames(data)), ] condition  <- unlist( lapply( strsplit( colnames(data), \"_cond_\"), `[`, 2)) condition <- data.frame(condition = condition ) design <- model.matrix(~condition, data = condition) fit <- lmFit(data, design) fit <- eBayes(fit) tT <- topTable(fit, n = Inf) tT$gene <- rownames(tT) p <- ggplot( tT , aes(logFC,-log10(P.Value) , text = gene ) )+       geom_point(aes(colour=-log10(P.Value)), alpha=1/3, size=1) +       scale_colour_gradient(low=\"blue\",high=\"red\")+       xlab(\"log2 fold change\") + ylab(\"-log10 p-value\") + theme_minimal()   ggplotly(p) # specify a folder to store the html report. Here we store it in the current working directory.  output_folder <-  getwd() run_association_study_report(scfeatures_result, output_folder )"},{"path":"/articles/disease_outcome_classification_schulte.html","id":"are-the-generated-features-sensible","dir":"Articles","previous_headings":"3. How can I characterise each individual as a whole from the matrix of genes x cells ?","what":"3.3 Are the generated features sensible?","title":"Disease Outcome Classification in Single Cell Patient Data Analysis","text":"Discussion: Using HTML, can look critical thinking questions researcher ask generated features. questions exploratory right wrong answer. generated features look reasonable? cell type(s) like focus next stage analysis? feature type(s) like focus next stage analysis? conditions data relatively easy difficult distinguish?","code":""},{"path":"/articles/disease_outcome_classification_schulte.html","id":"how-can-i-perform-disease-outcome-classification-using-the-molecular-representation-of-patients","dir":"Articles","previous_headings":"","what":"4. How can I perform disease outcome classification using the molecular representation of patients?","title":"Disease Outcome Classification in Single Cell Patient Data Analysis","text":"Now generated patient representation, section examine useful case study using representation perform disease outcome classification.","code":""},{"path":"/articles/disease_outcome_classification_schulte.html","id":"building-classification-model","dir":"Articles","previous_headings":"4. How can I perform disease outcome classification using the molecular representation of patients?","what":"4.1 Building classification model","title":"Disease Outcome Classification in Single Cell Patient Data Analysis","text":"workshop use classifyR package build classification model. provides implementation typical framework classification, including function performs repeated cross-validation one line code.  build classification model feature type. Recall previous section stored 13 feature types matrix list. Instead manually retrieving matrix list build separate models, classifyR can directly take list matrices input run repeated cross-validation model matrix individually. , run 5 repeats 2 folds cross-validation (save time).","code":"# First clean the column names for(i in 1:length(scfeatures_result)){   names(scfeatures_result[[i]]) <-  make.names(names(scfeatures_result[[i]])) }   # obtain the patient outcome, which is stored in the rownames of each matrix  outcome = scfeatures_result[[1]] %>% rownames %>% strsplit(\"_cond_\") %>% sapply(function(x) x[2]) classifyr_result = crossValidate(scfeatures_result,                                  outcome,                                   classifier = \"kNN\",                                  nFolds = 2,                                   nRepeats = 5,                                   nCores = 5 )"},{"path":"/articles/disease_outcome_classification_schulte.html","id":"visualising-the-classification-performance","dir":"Articles","previous_headings":"4. How can I perform disease outcome classification using the molecular representation of patients?","what":"4.2 Visualising the classification performance","title":"Disease Outcome Classification in Single Cell Patient Data Analysis","text":"examine classification model performance, first need specify metric calculate. , calculate balanced accuracy. Format output visualise accuracy using boxplots.  Interpretation: Based classification performance, feature type like focus next stage analysis?","code":"classifyr_result <- readRDS(\"~/intermediate_result/classifyr_result_knn.rds\")  classifyr_result <- lapply(classifyr_result, function(x) calcCVperformance(x, performanceType = \"Balanced Accuracy\")) accuracy_knn_balanced_accuracy  <- performancePlot(classifyr_result) + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) # make the x-axis label 45 degree so it's easier to read   accuracy_knn_balanced_accuracy"},{"path":"/articles/disease_outcome_classification_schulte.html","id":"what-features-are-important-for-disease-outcome-prediction","dir":"Articles","previous_headings":"4. How can I perform disease outcome classification using the molecular representation of patients?","what":"4.3 What features are important for disease outcome prediction?","title":"Disease Outcome Classification in Single Cell Patient Data Analysis","text":"Recall built 5 repeats 2-fold cross-validation models. means feature type, obtained total 10 models. Therefore, answer features important modelling, first need examine whether rankings (importance) feature model (within feature type) . give example, use feature type “gene_mean_celltype” look overlap top 20 ranked features 10 models.  Discussion: Based upset plot, top ranked features consistent? also leads next question, determine final set top features focus ? , use mean scores across folds calculate final set top features. Discussion: Explore ranks features. cell type(s) like focus next stage analysis ?","code":"# look at the list of models  names(classifyr_result) #>  [1] \"proportion_raw.kNN.t-test\"     \"proportion_logit.kNN.t-test\"   #>  [3] \"proportion_ratio.kNN.t-test\"   \"gene_mean_celltype.kNN.t-test\" #>  [5] \"gene_prop_celltype.kNN.t-test\" \"gene_cor_celltype.kNN.t-test\"  #>  [7] \"pathway_gsva.kNN.t-test\"       \"pathway_mean.kNN.t-test\"       #>  [9] \"pathway_prop.kNN.t-test\"       \"CCI.kNN.t-test\"                #> [11] \"gene_mean_bulk.kNN.t-test\"     \"gene_prop_bulk.kNN.t-test\"     #> [13] \"gene_cor_bulk.kNN.t-test\"  # pick the fourth model, which is on the feature type gene mean celltype gene_mean_celltype <- classifyr_result[[4]]  data_list <- gene_mean_celltype@rankedFeatures data_list <- lapply(data_list , function(df) {   df[, 2][1:20] })   names(data_list) <- paste0(\"Model\", 1:10) # Create the UpSet plot upset_plot <- upset(fromList(data_list), order.by = \"freq\", nsets = 10)  # Display the plot upset_plot top_features  <- lapply(1:10, function(x){   thismodel <- gene_mean_celltype@rankedFeatures[[x]]   thismodel$rank <- 1:nrow(thismodel)   thismodel <- thismodel[sort(rownames(thismodel)), ]   thismodel$model <- x   thismodel })  top_features <- as.data.frame( do.call(rbind, top_features ) )   top_features <- top_features %>% group_by(feature) %>% dplyr::summarise(rank = mean(rank)) %>% arrange(rank)  print(head(top_features,10)) #> # A tibble: 10 × 2 #>    feature               rank #>    <chr>                <dbl> #>  1 Neutrophil..SNX3      108. #>  2 gdT..SATB1            113. #>  3 Neutrophil..CAST      129. #>  4 Neutrophil..ALOX5AP   130  #>  5 Neutrophil..SH3BGRL3  147. #>  6 Neutrophil..FCER1G    153. #>  7 Neutrophil..PRR13     156. #>  8 Neutrophil..GRN       193. #>  9 Neutrophil..CDC42     216. #> 10 Neutrophil..YWHAB     226."},{"path":"/articles/disease_outcome_classification_schulte.html","id":"is-the-prediction-consistent-across-the-feature-types","dir":"Articles","previous_headings":"4. How can I perform disease outcome classification using the molecular representation of patients?","what":"4.4 Is the prediction consistent across the feature types","title":"Disease Outcome Classification in Single Cell Patient Data Analysis","text":"Given build prediction model feature type, can examine whether prediction feature type consistent.  Discussion: ensemble learning using feature types improve prediction performance compared using individual feature type ?","code":"# looking at one repeat  data_list <- lapply( 1:13 , function(i) {   prediction <- classifyr_result[[i]]@predictions    prediction <- prediction[prediction$permutation == 1, ]$class   prediction <- as.data.frame(prediction) })  data_list <- do.call( cbind, data_list) colnames(data_list)  <- names(classifyr_result)        # count the number of times each row is labeled as \"Mild/Moderate\" counts <- apply(data_list  == \"Mild/Moderate\", 1, sum)    # calculate the percentage of times each row is labeled as \"Mild/Moderate\" percentages <- counts / ncol(data_list) * 100   patient <- unlist ( lapply ( strsplit ( classifyr_result[[1]]@originalNames, \"_cond_\")  , `[` , 1) ) condition <-  unlist ( lapply ( strsplit ( classifyr_result[[1]]@originalNames, \"_cond_\")  , `[` , 2) ) consistency <- data.frame(patient = patient  ,                           condition = condition,                            percentages_mildmoderate = percentages ) rownames(consistency) <- NULL  consistency #>                                         patient       condition #> 1                         C19-CB-0003_d13-Fresh   Mild/Moderate #> 2                         C19-CB-0002_d13-Fresh   Mild/Moderate #> 3                         C19-CB-0002_d8-Frozen   Mild/Moderate #> 4                        C19-CB-0003_d18-Frozen   Mild/Moderate #> 5                          C19-CB-0009_d9-Fresh Severe/Critical #> 6                          C19-CB-0012_d9-Fresh Severe/Critical #> 7                         C19-CB-0008_d13-Fresh Severe/Critical #> 8                         C19-CB-0009_d16-Fresh Severe/Critical #> 9                         C19-CB-0021_d18-Fresh Severe/Critical #> 10                        C19-CB-0198_d18-Fresh Severe/Critical #> 11                         C19-CB-0214_d7-Fresh   Mild/Moderate #> 12 BN-18_FreshEryLysis_12.05.2020-FreshEryLysis Severe/Critical #>    percentages_mildmoderate #> 1                 92.307692 #> 2                 92.307692 #> 3                 38.461538 #> 4                 53.846154 #> 5                  0.000000 #> 6                 23.076923 #> 7                 84.615385 #> 8                 84.615385 #> 9                  7.692308 #> 10                 0.000000 #> 11                 7.692308 #> 12                 7.692308  # can also do it visually in one line via the function:  samplesMetricMap(classifyr_result) #> TableGrob (2 x 1) \"arrange\": 2 grobs #>   z     cells    name                grob #> 1 1 (2-2,1-1) arrange      gtable[layout] #> 2 2 (1-1,1-1) arrange text[GRID.text.678]"},{"path":"/articles/disease_outcome_classification_schulte.html","id":"is-the-constructed-model-robust-for-disease-outcome-classification","dir":"Articles","previous_headings":"","what":"5. Is the constructed model robust for disease outcome classification?","title":"Disease Outcome Classification in Single Cell Patient Data Analysis","text":"section take detailed look model performance. particular, number factors may affect classification performance, choice classification algorithm.","code":""},{"path":"/articles/disease_outcome_classification_schulte.html","id":"do-the-results-change-with-different-classification-algorithms","dir":"Articles","previous_headings":"5. Is the constructed model robust for disease outcome classification?","what":"5.1 Do the results change with different classification algorithms?","title":"Disease Outcome Classification in Single Cell Patient Data Analysis","text":"classifyR provides implementation number commonly used classification algorithms, including: - randomForest - DLDA - kNN - GLM - elasticNetGLM - SVM - NSC - naiveBayes - mixturesNormals - CoxPH - CoxNet - randomSurvivalForest - XGB Compare accuracy obtained different algorithms.","code":"classifyr_result = crossValidate(scfeatures_result,                                  outcome,                                   classifier = \"naiveBayes\",                                  nFolds = 2,                                   nRepeats = 5,                                   nCores = 5 ) classifyr_result <- readRDS(\"~/intermediate_result/classifyr_result_naivebayes.rds\")   accuracy_naivebayes_balanced_accuracy <- performancePlot(classifyr_result) + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))  accuracy_naivebayes_balanced_accuracy"},{"path":"/articles/disease_outcome_classification_schulte.html","id":"do-the-results-change-with-different-evaluation-metrics","dir":"Articles","previous_headings":"5. Is the constructed model robust for disease outcome classification?","what":"5.2 Do the results change with different evaluation metrics?","title":"Disease Outcome Classification in Single Cell Patient Data Analysis","text":"calculate accuracy instead balanced accuracy. Inspect difference performance.  Compare performance plot","code":"accuracy_naivebayes_accuracy  <- performancePlot(classifyr_result , metric =\"Accuracy\" ) + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))   accuracy_naivebayes_accuracy ggpubr::ggarrange(plotlist = list(accuracy_knn_balanced_accuracy,                                    accuracy_naivebayes_balanced_accuracy,                                   accuracy_naivebayes_accuracy),                    ncol=3)"},{"path":"/articles/disease_outcome_classification_schulte.html","id":"is-the-model-generalisable","dir":"Articles","previous_headings":"5. Is the constructed model robust for disease outcome classification?","what":"5.3 Is the model generalisable?","title":"Disease Outcome Classification in Single Cell Patient Data Analysis","text":"Generalisable means whether model can good performance tested independent dataset. , use model built Schulte-Schrepping dataset test Wilk dataset. Wilk data obtained Wilk et al. 2022. sampled 12 patients mild/moderate severe/critical conditions. First visualise data.  provided constructed scFeatures result Wilk dataset. Building model Schulte-Schrepping dataset features testing Wilk dataset. Visualise accuracy using boxplots.  Discussion: Examine classification accuracy comment generalisability model. Final discussion: good think model ? parts workflow change improve results?","code":"data <- readRDS(\"~/toy_data/wilk_12patients.rds\") data <- NormalizeData( data)  data <-  FindVariableFeatures(data )   data <- ScaleData(data, features = rownames(data) ) data <- RunPCA(data) data <- FindNeighbors(data, dims = 1:10) data <- FindClusters(data, resolution = 0.5) #> Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck #>  #> Number of nodes: 9029 #> Number of edges: 306374 #>  #> Running Louvain algorithm... #> Maximum modularity in 10 random starts: 0.9119 #> Number of communities: 13 #> Elapsed time: 1 seconds data  <- RunUMAP(data , dims = 1:10) DimPlot(data, reduction = \"umap\", group.by = \"meta_severity\") +  DimPlot(data, reduction = \"umap\", group.by = \"sample\") # Here we label the samples using the severity, such as it is easier later on to retrieve the severity outcomes of the samples.  data$sample <- paste0(data$sample, \"_cond_\" , data$meta_severity)  data <- process_data(data)  table(data$celltype) table(data$sample)   data <- data[, -c(which(data$sample %in% c(\"ED_084_PBMC_cond_Severe/Critical\",                                            \"Imm_006_ACK_cond_Mild/Moderate\"))) ] data <- data[, -c(which(data$celltype %in% c(\"DC\", \"DN\", \"gdT\",  \"HSPC\" , \"MAIT\" , \"MAST\", \"RBC\")))]   scfeatures_result_wilk <- scFeatures(data, ncores = 12) scfeatures_result_schulte <- readRDS(\"~/intermediate_result/scfeatures_result_schulte_12patients.rds\")  scfeatures_result_wilk <- readRDS(\"~/intermediate_result/scfeatures_result_wilk_12patients.rds\" )  scfeatures_result_wilk <- scfeatures_result_wilk[ names(scfeatures_result_schulte )]   # in order to train and test two different datasets, need to make sure the features are the same  # pick the common features  new_list <- lapply( 1:length(scfeatures_result_schulte), function(i){   common_features <- intersect(colnames( scfeatures_result_schulte[[i]]) ,                                colnames( scfeatures_result_wilk[[i]]))   new_schulte <-  scfeatures_result_schulte[[i]][, common_features]   new_wilk <- scfeatures_result_wilk[[i]][, common_features]   list(new_schulte, new_wilk) })  # format the features  new_scfeatures_result_schulte <- lapply(new_list, `[[`, 1) new_scfeatures_result_wilk <- lapply(new_list, `[[`, 2)  names(new_scfeatures_result_schulte) <- names(scfeatures_result_schulte) names(new_scfeatures_result_wilk) <- names(scfeatures_result_wilk)   # obtain the outcome, which is stored in the rownames of ech matrix  outcome_schulte = scfeatures_result_schulte[[1]] %>% rownames %>% strsplit(\"_cond_\") %>% sapply(function(x) x[2])  outcome_wilk = scfeatures_result_wilk[[1]] %>% rownames %>% strsplit(\"_cond_\") %>% sapply(function(x) x[2]) names(outcome_wilk) <- rownames(scfeatures_result_wilk[[1]]) # First clean the column names for(i in 1:length(new_scfeatures_result_schulte)){   names(new_scfeatures_result_schulte[[i]]) <-  make.names( names(new_scfeatures_result_schulte[[i]]) ) }   # First clean the column names for(i in 1:length(new_scfeatures_result_wilk)){   names(new_scfeatures_result_wilk[[i]]) <-  make.names( names(new_scfeatures_result_wilk[[i]]) ) }    # for each feature type, identify the best model and use the best model to predict on Wilk result_generalisability <- NULL  for( i in c(1:length( new_scfeatures_result_schulte )) ){    model <- train(x = new_scfeatures_result_schulte[[i]] ,outcomeTrain = outcome_schulte,                  performanceType = \"Balanced Accuracy\", classifier =  \"DLDA\" )   prediction  <- predict( model , new_scfeatures_result_wilk[[i]])   truth <-  outcome_wilk[rownames(prediction)]   prediction <- ifelse(prediction$`Mild/Moderate` > 0.5, \"Mild/Moderate\", \"Severe/Critical\" )   temp <- calcExternalPerformance( factor(truth) , factor(prediction),                                    performanceType = c(\"Balanced Accuracy\"))   temp <- data.frame(balanced_accuracy = temp,                      featuretype = names(new_scfeatures_result_schulte)[[i]] )   result_generalisability <- rbind(result_generalisability,   temp) } result_generalisability$balanced_accuracy <- round( result_generalisability$balanced_accuracy, 2)   result_generalisability$featuretype <- factor(  result_generalisability$featuretype , levels = c( result_generalisability$featuretype))  ggplot( result_generalisability, aes(x = featuretype , y = balanced_accuracy, fill = featuretype ) ) + geom_col()+ theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) + ylim(0,1) + scale_fill_tableau(palette = \"Tableau 20\") +   geom_text(aes(label = balanced_accuracy), vjust = -0.5)"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Sydney Precision Bioinformatics Alliance. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Sydney Precision Bioinformatics Alliance (2023). scdneyDiseasePrediction: Disease outcome prediction using scdney. R package version 0.1.0.","code":"@Manual{,   title = {scdneyDiseasePrediction: Disease outcome prediction using scdney},   author = {{Sydney Precision Bioinformatics Alliance}},   year = {2023},   note = {R package version 0.1.0}, }"},{"path":"/index.html","id":"scdneydiseaseprediction","dir":"","previous_headings":"","what":"Disease outcome prediction using scdney","title":"Disease outcome prediction using scdney","text":"https://sydneybiox.github.io/scdneyDiseasePrediction/","code":""},{"path":"/reference/hello.html","id":null,"dir":"Reference","previous_headings":"","what":"Hello, World! — hello","title":"Hello, World! — hello","text":"Prints 'Hello, world!'.","code":""},{"path":"/reference/hello.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hello, World! — hello","text":"","code":"hello()"},{"path":"/reference/hello.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hello, World! — hello","text":"","code":"hello() #> [1] \"Hello, world!\""}]
