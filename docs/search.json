[{"path":[]},{"path":"/articles/disease_outcome_classification_schulte.html","id":"description","dir":"Articles","previous_headings":"Overview","what":"Description","title":"Disease outcome classification in Single Cell Patient Data Analysis","text":"single-cell technology advances, number multi-condition multi-sample datasets increases. workshop discuss challenges analytical focus associated disease outcome prediction using single cell data, one analytics involved datasets. workshop’s overall learning goal investigate one possible approach task. also talk general analytic strategies critical thinking questions arise workflow.","code":""},{"path":"/articles/disease_outcome_classification_schulte.html","id":"preparation-and-assumed-knowledge","dir":"Articles","previous_headings":"Overview","what":"Preparation and assumed knowledge","title":"Disease outcome classification in Single Cell Patient Data Analysis","text":"Knowledge R syntax Familiarity Seurat class","code":""},{"path":"/articles/disease_outcome_classification_schulte.html","id":"learning-objectives","dir":"Articles","previous_headings":"Overview","what":"Learning objectives","title":"Disease outcome classification in Single Cell Patient Data Analysis","text":"Explore various strategies disease outcome prediction using single cell data Understand transformation cell level features patient level features Generate patient representations gene expression matrix Understand characteristics good classification models Perform disease outcome prediction using feature representation robust classification framework","code":""},{"path":"/articles/disease_outcome_classification_schulte.html","id":"time-outline","dir":"Articles","previous_headings":"Overview","what":"Time outline","title":"Disease outcome classification in Single Cell Patient Data Analysis","text":"Structure 2-hour workshop:","code":""},{"path":"/articles/disease_outcome_classification_schulte.html","id":"introduction","dir":"Articles","previous_headings":"","what":"1. Introduction","title":"Disease outcome classification in Single Cell Patient Data Analysis","text":"rise single-cell near single-cell resolution omics technologies (e.g. spatial transcriptomics) enabled discovery cell- cell type specific knowledge transformed understanding biological systems. high-dimensionality complexity, 1000 tools developed extract meaningful information high feature dimensions uncover biological insights. example, previous workshop focuses characterising identity state cells relationship cells along trajectory. tools enable characterisation individual cells, lack tools characterise individual samples whole based cellular properties investigate cellular properties driving disease outcomes. recent surge multi-condition multi-sample single-cell studies, question becomes represent cellular properties sample (e.g. individual patient) level linking information disease outcome performing downstream analysis disease outcome prediction. workshop, demonstrate approach generating molecular representation individual samples using representation downstream application disease outcome classification.","code":""},{"path":[]},{"path":"/articles/disease_outcome_classification_schulte.html","id":"load-libraries","dir":"Articles","previous_headings":"2. Loading libraries and the data","what":"2.1 Load libraries","title":"Disease outcome classification in Single Cell Patient Data Analysis","text":"First, load libraries using workshop.","code":"for (thispackage in c(\"ggplot2\",  \"ggthemes\" , \"Seurat\" , \"dplyr\" , \"devtools\",                       \"RCurl\")){   if(! thispackage %in% installed.packages() ){     install.packages(thispackage )   } }  library(ggplot2) library(ggthemes) theme_set(theme_bw()) library(Seurat) library(dplyr) library(devtools)  library(RCurl)  if (! \"scFeatures\" %in% installed.packages() ){   devtools::install_github(\"SydneyBioX/scFeatures\") } library(scFeatures)  if (! \"ClassifyR\" %in% installed.packages() ){   if (!require(\"BiocManager\", quietly = TRUE)){      install.packages(\"BiocManager\")}    BiocManager::install(\"ClassifyR\") } library(ClassifyR)  set.seed(2022)"},{"path":"/articles/disease_outcome_classification_schulte.html","id":"loading-the-preprocessed-data","dir":"Articles","previous_headings":"2. Loading libraries and the data","what":"2.2 Loading the preprocessed data","title":"Disease outcome classification in Single Cell Patient Data Analysis","text":"use single-cell RNA-sequencing (scRNA-seq) data COVID-19 patients workshop. dataset taken Schulte-Schrepping et al. 2020. subsampled 20 mild 20 severe patient samples dataset. original data can accessed European Genome-phenome Archive (EGA) accession number EGAS00001004571.","code":"download.file(url = \"http://www.dropbox.com/s/vhnwch3362dlwr5/Schulte-schrepping_20_severe_20_mild.rds?raw=1\" , destfile = \"toy_data/Schulte-schrepping_20_severe_20_mild.rds\" , method=\"auto\" )  data <-  readRDS(\"toy_data/Schulte-schrepping_20_severe_20_mild.rds\")"},{"path":"/articles/disease_outcome_classification_schulte.html","id":"visualising-the-data","dir":"Articles","previous_headings":"2. Loading libraries and the data","what":"2.3 Visualising the data","title":"Disease outcome classification in Single Cell Patient Data Analysis","text":"can visualise data using dimensionality reduction approaches colour individual cells severity.  Interpretation: cells mild/moderate severe/critical patients easy difficult distinguish?","code":"data <- NormalizeData( data)  data <-  FindVariableFeatures(data )   data <- ScaleData(data, features = rownames(data) ) data <- RunPCA(data) data <- FindNeighbors(data, dims = 1:10) data <- FindClusters(data, resolution = 0.5) #> Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck #>  #> Number of nodes: 37210 #> Number of edges: 1210153 #>  #> Running Louvain algorithm... #> Maximum modularity in 10 random starts: 0.9436 #> Number of communities: 26 #> Elapsed time: 7 seconds data  <- RunUMAP(data , dims = 1:10) DimPlot(data, reduction = \"umap\", group.by = \"meta_severity\")"},{"path":"/articles/disease_outcome_classification_schulte.html","id":"how-can-i-characterise-each-individual-as-a-whole-from-the-matrix-of-genes-x-cells","dir":"Articles","previous_headings":"","what":"3. How can I characterise each individual as a whole from the matrix of genes x cells ?","title":"Disease outcome classification in Single Cell Patient Data Analysis","text":"workshop, use scFeatures generate molecular representation patient. molecular representation interpretable hence facilitates downstream analysis patient. Overall, scFeatures generates features across six categories representing different molecular views cellular characteristics. include: - ) cell type proportions - ii) cell type specific gene expressions - iii) cell type specific pathway expressions - iv) cell type specific cell-cell interaction (CCI) scores - v) overall aggregated gene expressions - vi) spatial metrics different types features constructed enable comprehensive multi-view understanding patient matrix genes x cells.","code":""},{"path":"/articles/disease_outcome_classification_schulte.html","id":"checking-the-data","dir":"Articles","previous_headings":"3. How can I characterise each individual as a whole from the matrix of genes x cells ?","what":"3.1 Checking the data","title":"Disease outcome classification in Single Cell Patient Data Analysis","text":"Inspect number cells patient sample, well number cells cell type. Discussion: sample cell types remove data? Discussion: running process_data function, still patient samples cell types remove data?","code":"table(data$sample) #>  #>       BN-03_FrozenPBMC_03.04.2020-FrozenPBMC  #>                                         1000  #> BN-04_FreshEryLysis_23.04.2020-FreshEryLysis  #>                                         1000  #> BN-05_FreshEryLysis_23.04.2020-FreshEryLysis  #>                                         1000  #> BN-06_FreshEryLysis_23.04.2020-FreshEryLysis  #>                                         1000  #> BN-08_FreshEryLysis_29.05.2020-FreshEryLysis  #>                                          994  #> BN-11_FreshEryLysis_23.04.2020-FreshEryLysis  #>                                         1000  #> BN-12_FreshEryLysis_14.05.2020-FreshEryLysis  #>                                         1000  #> BN-12_FreshEryLysis_18.05.2020-FreshEryLysis  #>                                          410  #> BN-18_FreshEryLysis_12.05.2020-FreshEryLysis  #>                                         1000  #> BN-18_FreshEryLysis_14.05.2020-FreshEryLysis  #>                                         1000  #> BN-18_FreshEryLysis_18.05.2020-FreshEryLysis  #>                                         1000  #> BN-19_FreshEryLysis_12.05.2020-FreshEryLysis  #>                                         1000  #> BN-19_FreshEryLysis_14.05.2020-FreshEryLysis  #>                                         1000  #>                        C19-CB-0001_d11-Fresh  #>                                          970  #>                       C19-CB-0001_d16-Frozen  #>                                          273  #>                        C19-CB-0001_d7-Frozen  #>                                         1000  #>                        C19-CB-0002_d13-Fresh  #>                                         1000  #>                        C19-CB-0002_d8-Frozen  #>                                         1000  #>                        C19-CB-0003_d13-Fresh  #>                                         1000  #>                       C19-CB-0003_d18-Frozen  #>                                         1000  #>                       C19-CB-0005_d15-Frozen  #>                                          448  #>                       C19-CB-0005_d20-Frozen  #>                                          875  #>                        C19-CB-0008_d13-Fresh  #>                                         1000  #>                        C19-CB-0008_d20-Fresh  #>                                         1000  #>                        C19-CB-0009_d16-Fresh  #>                                         1000  #>                         C19-CB-0009_d9-Fresh  #>                                          938  #>                        C19-CB-0011_d13-Fresh  #>                                          932  #>                        C19-CB-0012_d16-Fresh  #>                                         1000  #>                         C19-CB-0012_d9-Fresh  #>                                          741  #>                        C19-CB-0013_d15-Fresh  #>                                         1000  #>                         C19-CB-0013_d8-Fresh  #>                                          629  #>                        C19-CB-0016_d16-Fresh  #>                                         1000  #>                        C19-CB-0020_d16-Fresh  #>                                         1000  #>                        C19-CB-0021_d18-Fresh  #>                                         1000  #>                       C19-CB-0052_d10-Frozen  #>                                         1000  #>                        C19-CB-0053_d3-Frozen  #>                                         1000  #>                        C19-CB-0198_d18-Fresh  #>                                         1000  #>                         C19-CB-0199_d8-Fresh  #>                                         1000  #>                        C19-CB-0204_d15-Fresh  #>                                         1000  #>                         C19-CB-0214_d7-Fresh  #>                                         1000 table(data$celltype) #>  #>            B    CD14 Mono    CD16 Mono        CD4 T        CD8 T           DC  #>         1863         7241          919         7612         1763          260  #>           DN          gdT         HSPC          ILC intermediate         MAIT  #>           52          264           43            1          645          328  #>         MAST   Neutrophil           NK          NKT       Plasma     Platelet  #>           60         9853         3518         1561          513          404  #>          RBC   unassigned  #>            2          308"},{"path":"/articles/disease_outcome_classification_schulte.html","id":"creating-molecular-representations-of-patients","dir":"Articles","previous_headings":"3. How can I characterise each individual as a whole from the matrix of genes x cells ?","what":"3.1 Creating molecular representations of patients","title":"Disease outcome classification in Single Cell Patient Data Analysis","text":"feature types can generated one line code. runs function using default settings parameters, information, type ?scFeatures. Given step may take 20 minutes, already generated result saved intermediate_result folder. skip step proceed next step purposes workshop.","code":"# Here we label the samples using the severity, such as it is easier later on to retrieve the severity outcomes of the samples.  data$sample <- paste0(data$sample, \"_cond_\" , data$meta_severity)   scfeatures_result <- scFeatures(data, ncores = 8)  # setwd(\"intermediate_result/\") # saveRDS( scfeatures_result , \"scfeatures_result_wilk_full.rds\")"},{"path":"/articles/disease_outcome_classification_schulte.html","id":"visualising-and-exploring-scfeatures-output","dir":"Articles","previous_headings":"3. How can I characterise each individual as a whole from the matrix of genes x cells ?","what":"3.2 Visualising and exploring scFeatures output","title":"Disease outcome classification in Single Cell Patient Data Analysis","text":"generated total 13 feature types stored list. generated feature types stored matrix samples features. example, first list element contains feature type “proportion_raw”, contains cell type proportion features patient sample. print first 5 columns first 5 rows first element see. features generated, may wish visually explore features. example, cell-cell communication, heatmap summarising number interactions cell types provide direct insight matrix interaction scores. accommodate need, scFeatures contains function run_association_study_report enables user readily visualise explore generated features one line code. Note, function knits rmd file, please open new R script, paste command run .","code":"download.file(url = \"https://www.dropbox.com/s/volcbtmcz4nlqw4/scfeatures_result_schulte.rds?raw=1\" , destfile = \"intermediate_result/scfeatures_result_schulte.rds\" , method=\"auto\" )   scfeatures_result <- readRDS(\"intermediate_result/scfeatures_result_schulte.rds\")  # we have generated a total of 13 feature types names(scfeatures_result) #>  [1] \"proportion_raw\"       \"proportion_logit\"     \"proportion_ratio\"     #>  [4] \"gene_mean_celltype\"   \"gene_prop_celltype\"   \"gene_cor_celltype\"    #>  [7] \"pathway_gsva\"         \"pathway_mean\"         \"pathway_prop\"         #> [10] \"CCI\"                  \"gene_mean_aggregated\" \"gene_prop_aggregated\" #> [13] \"gene_cor_aggregated\"  # each row is a sample, each column is a feature  scfeatures_result[[1]][1:5, 1:5] #>                                                   B CD14 Mono  CD16 Mono #> C19-CB-0001_d11-Fresh_cond_Mild/Moderate  0.2033024 0.4210526 0.02373581 #> C19-CB-0003_d13-Fresh_cond_Mild/Moderate  0.1524574 0.5687061 0.06218656 #> C19-CB-0002_d13-Fresh_cond_Mild/Moderate  0.2312312 0.2732733 0.03203203 #> C19-CB-0002_d8-Frozen_cond_Mild/Moderate  0.0670000 0.2780000 0.03000000 #> C19-CB-0001_d16-Frozen_cond_Mild/Moderate 0.2271062 0.3333333 0.04395604 #>                                                CD4 T      CD8 T #> C19-CB-0001_d11-Fresh_cond_Mild/Moderate  0.12899897 0.02270382 #> C19-CB-0003_d13-Fresh_cond_Mild/Moderate  0.02407222 0.02407222 #> C19-CB-0002_d13-Fresh_cond_Mild/Moderate  0.06006006 0.05205205 #> C19-CB-0002_d8-Frozen_cond_Mild/Moderate  0.04600000 0.06200000 #> C19-CB-0001_d16-Frozen_cond_Mild/Moderate 0.11721612 0.02564103 # specify a folder to store the html report. Here we store it in the current working directory.  output_folder <-  getwd() run_association_study_report(scfeatures_result, output_folder )"},{"path":"/articles/disease_outcome_classification_schulte.html","id":"are-the-generated-features-sensible","dir":"Articles","previous_headings":"3. How can I characterise each individual as a whole from the matrix of genes x cells ?","what":"3.3 Are the generated features sensible?","title":"Disease outcome classification in Single Cell Patient Data Analysis","text":"Discussion: Using HTML, can look critical thinking questions researcher ask generated features. questions exploratory right wrong answer. generated features look reasonable? cell type(s) like focus next stage analysis? feature type(s) like focus next stage analysis? conditions data relatively easy difficult distinguish?","code":""},{"path":"/articles/disease_outcome_classification_schulte.html","id":"how-can-i-perform-disease-outcome-classification-using-the-molecular-representation-of-patients","dir":"Articles","previous_headings":"","what":"4. How can I perform disease outcome classification using the molecular representation of patients?","title":"Disease outcome classification in Single Cell Patient Data Analysis","text":"Now generated patient representation, section examine useful case study using representation perform disease outcome classification.","code":""},{"path":"/articles/disease_outcome_classification_schulte.html","id":"building-classification-model","dir":"Articles","previous_headings":"4. How can I perform disease outcome classification using the molecular representation of patients?","what":"4.1 Building classification model","title":"Disease outcome classification in Single Cell Patient Data Analysis","text":"workshop use classifyR package build classification model. provides implementation typical framework classification, including function performs repeated cross-validation one line code.  build classification model feature type. Recall previous section stored 13 feature types matrix list. Instead retrieving matrix list, classifyR can directly take list matrices input run repeated cross-validation model matrix individually.","code":"# First clean the column names for(i in 1:length(scfeatures_result)){   names(scfeatures_result[[i]]) <- gsub(\"\\\\s|[[:punct:]]\", \".\", names(scfeatures_result[[i]])) }  # obtain the patient outcome, which is stored in the rownames of each matrix  outcome = scfeatures_result[[1]] %>% rownames %>% strsplit(\"_cond_\") %>% sapply(function(x) x[2]) classifyr_result = crossValidate(scfeatures_result,                             outcome,                              classifier = \"DLDA\",                             nCores = 10 )  # because this can take a while, save for future use # saveRDS(\"intermediate_result/classifyr_result.rds)"},{"path":"/articles/disease_outcome_classification_schulte.html","id":"visualising-the-classification-performance","dir":"Articles","previous_headings":"4. How can I perform disease outcome classification using the molecular representation of patients?","what":"4.2 Visualising the classification performance","title":"Disease outcome classification in Single Cell Patient Data Analysis","text":"examine classification model performance, first need specify metric calculate. , calculate balanced accuracy. Format output visualise accuracy using boxplots.  Interpretation: Based classification performance, feature type like focus next stage analysis?","code":"download.file(url = \"https://www.dropbox.com/s/4018lih0qxrgg96/classifyr_result_DLDA.rds?raw=1\" , destfile =\"intermediate_result/classifyr_result_DLDA.rds\" , method=\"auto\" )   classifyr_result <- readRDS(\"intermediate_result/classifyr_result_DLDA.rds\")  classifyr_result <- lapply(classifyr_result, function(x) calcCVperformance(x, performanceType = \"Balanced Accuracy\")) accuracy <- data.frame( lapply(classifyr_result, performance) )  colnames(accuracy ) <- unlist( lapply ( strsplit( names(classifyr_result) , \"\\\\.\" ), `[` , 1))  accuracy <- reshape2::melt(accuracy)  accuracy_DLDA <- ggplot(accuracy, aes(x = variable, y = value)) + geom_boxplot() + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) + xlab(\"Feature types\") + ylab(\"Balanced Accuracy - DLDA\")+ ylim(0,1)  accuracy_DLDA"},{"path":"/articles/disease_outcome_classification_schulte.html","id":"what-features-are-important-for-disease-outcome-prediction","dir":"Articles","previous_headings":"4. How can I perform disease outcome classification using the molecular representation of patients?","what":"4.3 What features are important for disease outcome prediction?","title":"Disease outcome classification in Single Cell Patient Data Analysis","text":"classifyR, default settings perform 20 repeats 5-fold cross-validation, giving rise total 100 models. Therefore, answer features important modelling, first need examine whether rankings (importance) feature model . use feature type “gene_mean_celltype” example illustrate. , pick one cell type specific genes CREB3 look ranks across 100 models. (smaller rank, better. Rank 1 indicates feature important model.)  feature type contains total 26076 features. Therefore, although boxplot shows certain variability ranks features, overall consistent expression CREB3 plasma cells important contribution towards classification model. leads next question, determine final set top features focus ? , use mean scores across folds calculate final set top features. Discussion: explore ranks features. cell type(s) like focus next stage analysis ?","code":"gene_mean_celltype <- classifyr_result[[\"gene_mean_celltype.DLDA.t-test\"  ]]  Plasma_CREB3_rank  <- lapply(1:100, function(x){     thismodel <- gene_mean_celltype@rankedFeatures[[x]]     thismodel$rank <- 1:nrow(thismodel)     thismodel[\"Plasma..CREB3\", ]$rank })  Plasma_CREB3_rank <- data.frame( rank = unlist(Plasma_CREB3_rank) )  ggplot(Plasma_CREB3_rank, aes( x = \"model\", y = rank)) + geom_boxplot() top_features  <- lapply(1:100, function(x){     thismodel <- gene_mean_celltype@rankedFeatures[[x]]     thismodel$rank <- 1:nrow(thismodel)     thismodel <- thismodel[sort(rownames(thismodel)), ]     thismodel$model <- x     thismodel })  top_features <- as.data.frame( do.call(rbind, top_features ) )   top_features <- top_features %>% group_by(feature) %>% dplyr::summarise(rank = mean(rank)) %>% arrange(rank)  print(head(top_features,10)) #> # A tibble: 10 × 2 #>    feature              rank #>    <chr>               <dbl> #>  1 Neutrophil..CD63     5.88 #>  2 Neutrophil..S100A12 12.4  #>  3 Neutrophil..TSPO    12.7  #>  4 Neutrophil..S100P   13.3  #>  5 Neutrophil..MYL6    16.6  #>  6 CD4.T..LDHA         17.3  #>  7 CD4.T..GAPDH        20.8  #>  8 Neutrophil..TOMM7   21.4  #>  9 Neutrophil..CYBB    21.4  #> 10 Neutrophil..PRDX5   25.0"},{"path":"/articles/disease_outcome_classification_schulte.html","id":"is-the-constructed-model-robust-for-disease-outcome-classification","dir":"Articles","previous_headings":"","what":"5. Is the constructed model robust for disease outcome classification?","title":"Disease outcome classification in Single Cell Patient Data Analysis","text":"section take detailed look model performance. particular, number factors may affect classification performance, choice classification algorithm.","code":""},{"path":"/articles/disease_outcome_classification_schulte.html","id":"do-the-results-change-with-different-classification-algorithms","dir":"Articles","previous_headings":"5. Is the constructed model robust for disease outcome classification?","what":"5.1 Do the results change with different classification algorithms?","title":"Disease outcome classification in Single Cell Patient Data Analysis","text":"classifyR provides implementation number commonly used classification algorithms. Compare accuracy obtained different algorithms.","code":"classifyr_result_svm = crossValidate(scfeatures_result,                             outcome,                              classifier = \"SVM\",                             nCores = 20) format_accuracy <- function(result_list, performanceType = \"Balanced Accuracy\"){      result_list <- lapply(result_list, function(x) calcCVperformance(x, performanceType = performanceType ))    accuracy <- lapply(result_list, performance)   accuracy  <- lapply(accuracy , `[`, performanceType)   accuracy <- data.frame( accuracy  )     colnames(accuracy ) <- unlist( lapply ( strsplit( names(result_list) , \"\\\\.\" ), `[` , 1))    accuracy <- reshape2::melt(accuracy)      return(accuracy) }   download.file(url = \"https://www.dropbox.com/s/43c72sqcxnwnjpi/classifyr_result_SVM.rds?raw=1\" , destfile = \"intermediate_result/classifyr_result_SVM.rds\" , method=\"auto\" )  classifyr_result_SVM <- readRDS(\"intermediate_result/classifyr_result_SVM.rds\")  accuracy_SVM <- format_accuracy(classifyr_result_SVM )  accuracy_SVM <- ggplot(accuracy_SVM, aes(x = variable, y = value )) + geom_boxplot() + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) + xlab(\"Feature types\") + ylab(\"Balanced Accuracy - SVM\") + ylim(0,1)  accuracy_SVM # ggplot(accuracy_SVM, aes(x = variable, y = value, colour = variable )) + geom_boxplot() + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) + xlab(\"Feature types\") + ylab(\"Balanced Accuracy - SVM\") + scale_colour_tableau(\"Tableau 20\")+ ylim(0,1)   # ggsave(\"accuracy_on_schulte.pdf\", width = 16, height = 10, units= \"cm\")"},{"path":"/articles/disease_outcome_classification_schulte.html","id":"do-the-results-change-with-different-evaluation-metrics","dir":"Articles","previous_headings":"5. Is the constructed model robust for disease outcome classification?","what":"5.2 Do the results change with different evaluation metrics?","title":"Disease outcome classification in Single Cell Patient Data Analysis","text":"calculate accuracy instead balanced accuracy. Inspect difference performance.","code":"classifyr_result_accuracy <- lapply(classifyr_result_SVM, function(x) calcCVperformance(x, performanceType = \"Accuracy\" ))      accuracy_SVM_accuracy <- format_accuracy(classifyr_result_accuracy)  accuracy_SVM_accuracy  <- ggplot(accuracy_SVM_accuracy , aes(x = variable, y = value)) + geom_boxplot() + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) + xlab(\"Feature types\") + ylab(\"Balanced Accuracy - SVM Accuracy\")+ ylim(0,1)  accuracy_SVM_accuracy"},{"path":"/articles/disease_outcome_classification_schulte.html","id":"is-the-model-generalisable","dir":"Articles","previous_headings":"5. Is the constructed model robust for disease outcome classification?","what":"5.3 Is the model generalisable?","title":"Disease outcome classification in Single Cell Patient Data Analysis","text":"Generalisable means whether model can good performance tested independent dataset. , use model built Schulte-Schrepping dataset test Wilk dataset. Wilk data obtained Wilk et al. 2022. contains 23 mild 19 severe patients. First visualise data.  provided constructed scFeatures result Wilk dataset. First, use dataset Schulte-Schrepping perform self cross-validation. purpose identify best model (best parameters). decide best model, use model test Wilk dataset. Visualise accuracy using boxplots.  Discussion: Examine classification accuracy comment generalisability model. Final discussion: good think model ? parts workflow change improve results?","code":"download.file(url = \"https://www.dropbox.com/s/6ecpzf2qrnglayg/wilk_full.rds?raw=1\" , destfile = \"toy_data/wilk_full.rds\" , method=\"auto\" )   data <- readRDS(\"toy_data/wilk_full.rds\") data <- NormalizeData( data)  data <-  FindVariableFeatures(data )   data <- ScaleData(data, features = rownames(data) ) data <- RunPCA(data) data <- FindNeighbors(data, dims = 1:10) data <- FindClusters(data, resolution = 0.5) #> Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck #>  #> Number of nodes: 112589 #> Number of edges: 3319297 #>  #> Running Louvain algorithm... #> Maximum modularity in 10 random starts: 0.9204 #> Number of communities: 19 #> Elapsed time: 88 seconds data  <- RunUMAP(data , dims = 1:10) DimPlot(data, reduction = \"umap\", group.by = \"meta_severity\") scfeatures_result_schulte <- readRDS(\"intermediate_result/scfeatures_result_schulte.rds\")  download.file(url = \"https://www.dropbox.com/s/wihtyecqmouf22a/scfeatures_result_wilk_full.rds?raw=1\" , destfile = \"intermediate_result/scfeatures_result_wilk_full.rds\" , method=\"auto\" )     scfeatures_result_wilk <- readRDS(\"intermediate_result/scfeatures_result_wilk_full.rds\" )  scfeatures_result_wilk <- scfeatures_result_wilk[ names(scfeatures_result_schulte )]   # in order to train and test two different datasets, need to make sure the features are the same  # pick the common features  new_list <- lapply( 1:length(scfeatures_result_schulte), function(i){    common_features <- intersect(colnames( scfeatures_result_schulte[[i]]) ,              colnames( scfeatures_result_wilk[[i]]))    new_schulte <-  scfeatures_result_schulte[[i]][, common_features]    new_wilk <- scfeatures_result_wilk[[i]][, common_features]    list(new_schulte, new_wilk) })  # format the features  new_scfeatures_result_schulte <- lapply(new_list, `[[`, 1) new_scfeatures_result_wilk <- lapply(new_list, `[[`, 2)  names(new_scfeatures_result_schulte) <- names(scfeatures_result_schulte) names(new_scfeatures_result_wilk) <- names(scfeatures_result_wilk)  # First clean the column names for(i in 1:length(new_scfeatures_result_schulte)){   names(new_scfeatures_result_schulte[[i]]) <- gsub(\"\\\\s|[[:punct:]]\", \".\", names(new_scfeatures_result_schulte[[i]])) }  # obtain the outcome, which is stored in the rownames of ech matrix  outcome_schulte = scfeatures_result_schulte[[1]] %>% rownames %>% strsplit(\"_cond_\") %>% sapply(function(x) x[2])  outcome_wilk = scfeatures_result_wilk[[1]] %>% rownames %>% strsplit(\"_cond_\") %>% sapply(function(x) x[2]) names(outcome_wilk) <- rownames(scfeatures_result_wilk[[1]])  # lapply(new_scfeatures_result_schulte, dim) # lapply(new_scfeatures_result_wilk, dim)  # remove the feature types that have no common features  # new_scfeatures_result_schulte[[6]] <- NULL # new_scfeatures_result_wilk[[6]] <- NULL # perform self cross validation classifyr_result_svm = crossValidate(new_scfeatures_result_schulte,                             outcome_schulte,                              classifier = \"SVM\",                             nCores = 20)  # calculate balanced accuracy   classifyr_result_svm  <- lapply(classifyr_result_svm, function(x) calcCVperformance(x, performanceType = \"Balanced Accuracy\" ))  # for each feature type, identify the best model and use the best model to predict on Wilk   result_generalisability <- NULL for( i in c(1:length( classifyr_result_svm )) ){   bestmodel <- classifyr_result_svm[[i]]@finalModel[[1]]      tuneList <- list(cost =  bestmodel$cost,                     gamma = bestmodel$gamma,                     degree = bestmodel$degree,                     type = bestmodel$type,                    tot.nSV= bestmodel$tot.nSV)       model <- train(x = new_scfeatures_result_schulte[[i]] ,outcomeTrain = outcome_schulte,                   performanceType = \"Balanced Accuracy\", classifier = \"SVM\",                   tuneParams = tuneList)       prediction  <- predict( model , new_scfeatures_result_wilk[[i]])      truth <-  outcome_wilk[names(prediction)]   temp <- calcExternalPerformance( factor(truth) , prediction,                                        performanceType = c(\"Balanced Accuracy\" ))    temp <- data.frame(balanced_accuracy = temp,                       featuretype = names(new_scfeatures_result_schulte)[[i]] )         result_generalisability <- rbind(result_generalisability,   temp) }  # saveRDS( result_generalisability, \"intermediate_result/result_list_generalisability.rds\") download.file(url = \"https://www.dropbox.com/s/9fmyvw9z1eh47ps/result_list_generalisability.rds?raw=1\" , destfile = \"intermediate_result/result_list_generalisability.rds\" , method=\"auto\" )    result_list_generalisability <- readRDS(\"intermediate_result/result_list_generalisability.rds\")   result_list_generalisability$balanced_accuracy <- round( result_list_generalisability$balanced_accuracy, 2)      result_list_generalisability$featuretype <- factor(  result_list_generalisability$featuretype , levels = c( result_list_generalisability$featuretype))   ggplot( result_list_generalisability, aes(x = featuretype , y = balanced_accuracy, fill = featuretype ) ) + geom_col()+ theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) + ylim(0,1) + scale_fill_tableau(palette = \"Tableau 20\") + geom_text(aes(label = balanced_accuracy), vjust = -0.5) # ggsave(\"accuracy_on_wilk.pdf\" , width = 16, height = 10, units = \"cm\")"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Sydney Precision Bioinformatics Alliance. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Sydney Precision Bioinformatics Alliance (2022). scdneyDiseasePrediction: Disease outcome prediction using scdney. R package version 0.1.0.","code":"@Manual{,   title = {scdneyDiseasePrediction: Disease outcome prediction using scdney},   author = {{Sydney Precision Bioinformatics Alliance}},   year = {2022},   note = {R package version 0.1.0}, }"},{"path":"/reference/hello.html","id":null,"dir":"Reference","previous_headings":"","what":"Hello, World! — hello","title":"Hello, World! — hello","text":"Prints 'Hello, world!'.","code":""},{"path":"/reference/hello.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hello, World! — hello","text":"","code":"hello()"},{"path":"/reference/hello.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hello, World! — hello","text":"","code":"hello() #> [1] \"Hello, world!\""}]
